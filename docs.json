[{"name":"NameVisitor","comment":" Visit each call in the module.\n\nA \"call\" is a `Node ( ModuleName, String )` and represents any value or type reference. Here are some examples:\n\n  - `Json.Encode.Value` -> `( [ \"Json\", \"Encode\" ], \"Value\" )`\n  - `Html.Attributes.class` -> `( [ \"Html\", \"Attributes\" ], \"class\" )`\n  - `Page` -> `( [], \"Page\" )`\n  - `view` -> `( [], \"view\" )`\n\nThese can appear in many places throughout declarations and expressions, and picking them out each time is a lot of work.\nInstead of writing 250 lines each time, you can write one `nameVisitor` and plug it straight into your module schema:\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> NameVisitor.withNameVisitor nameVisitor\n            |> Rule.fromModuleRuleSchema\n\n    callListVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    callListVisitor node context =\n        -- Do what you want with the node found\n        ( [], context )\n\n@docs withNameVisitor\n\n@docs declarationListVisitor, expressionVisitor\n\n","unions":[],"aliases":[],"values":[{"name":"declarationListVisitor","comment":" A declaration list visitor that will run your call visitor.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> Rule.withDeclarationListVisitor (declarationListVisitor nameVisitor)\n            |> Rule.fromModuleRuleSchema\n\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> List.List (Elm.Syntax.Node.Node Elm.Syntax.Declaration.Declaration) -> context -> ( List.List (Review.Rule.Error {}), context )"},{"name":"expressionVisitor","comment":" An expression visitor that will run your call visitor.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> Rule.withExpressionVisitor (expressionVisitor nameVisitor)\n            |> Rule.fromModuleRuleSchema\n\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> Review.Rule.Direction -> context -> ( List.List (Review.Rule.Error {}), context )"},{"name":"withNameVisitor","comment":" Adds a `declarationListVisitor` and an `expressionVisitor`.\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : () } context -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : (), hasAtLeastOneVisitor : () } context"}],"binops":[]}]